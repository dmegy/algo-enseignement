
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[top=3cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{amsthm}
\usepackage{layout}
\usepackage{fancyhdr}

\newtheorem*{thm}{Théorème}
\newtheorem{ex}{Exercice}
\newtheorem*{nota}{Notation}
\newtheorem*{rem}{Remarque}
\newtheorem*{rem2}{Remarques}
\newtheorem{de2}{Définition}
\newtheorem{pro2}[de2]{Propriété}
\newtheorem{thm2}[de2]{Théorème}

\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\usepackage{comment}

\title{}

\date{}
\begin{document}


\pagestyle{fancy}

\fancyhead{}
 \fancyfoot{}

 \lhead{ 2023/2024 \\  L3 Mathématiques
}
\chead{\textbf{ Algorithmes pour l'enseignement}\\} 
 \rhead{ Université de Lorraine \\  }

\newcommand{\lb}{\llbracket}
\newcommand{\rb}{\rrbracket}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}




\newcommand{\md}[3]{#1\ \equiv \ #2 \! \! \! \! \! \pmod {#3} }
\newcommand{\nmd}[3]{#1 \not \equiv #2 \! \! \! \! \!  \pmod {#3} }
\newcommand{\mda}[3]{#1 \equiv #2 \! \!  \pmod {#3} }
\newcommand{\nmda}[3]{#1 \not \equiv #2 \! \! \pmod {#3} }
\newcommand{\mo}[2]{#1 \! \! \! \! \! \pmod #2 }
\newcommand{\moa}[2]{#1 \! \!  \pmod {#2} }

\thispagestyle{fancy}

\begin{center}
%    \HRule \\[0.6cm]
    { \huge \bfseries
Examen du jeudi 9 novembre 2023
     \\ [0cm] }
    \HRule \\[0.5cm]
\end{center}

\begin{center}
\textbf{durée : 2 heures}
\end{center}



Pour chacun des algorithmes, on justifiera avec soin : \begin{itemize}
\item[•] que l'algorithme termine (si une boucle «~tant que~» est utilisée).

\item[•] que l'algorithme renvoie bien le résultat demandé.
\end{itemize}

Une réponse non justifiée sera notée sur les trois quarts des points.


\bigskip

Pour les boucles «~pour~», on adoptera les conventions suivantes. Si $a,b\in \Z$, «~pour $i$ allant de $a$ à $b$~» signifie «~pour $i$ parcourant en croissant l'intervalle $\llbracket a,b\rrbracket$~». Lorsque $b<a$, cet intervalle est vide, donc aucune des instructions dans la boucle «~pour~» n'est effectuée (ce sera par exemple le cas si on écrit «~pour $i$ allant de $1$ à $n$~», avec $n=0$). 
On pourra utiliser l'instruction «~pour $i$ allant en décroissant de $b$ à $a$~», qui signifie (si $b\geq a$) «~pour $i$ prenant successivement les valeurs $b$, $b-1$,$\ldots$, $a$~». Lorsque $a>b$, aucune instruction dans la boucle «~pour~» n'est alors effectuée.





\begin{ex}\label{prelim}
Écrire un algorithme pour calculer chacune des valeurs suivantes : 
\begin{enumerate}
\item pour $x\in\R$ donné, calculer $|x|$,
\item pour $n\in\N$ donné, calculer $n!$,
\item pour $x\in\R$ et $n\in\N$ donnés, calculer $x^n$, de manière itérative, puis récursive, (de manière basique, sans exponentiation rapide),
\item pour $x\in\R$ et $n\in\N$ donnés, calculer $S = \sum_{k=0}^n
  \frac{x^k}{k!}$ ; pour ce calcul, on donnera un algorithme basique  utilisant les algorithmes précédents,
  et un algorithme minimisant le nombre d'opérations,
  
\item   le maximum d'une liste $L$ non-vide.
\end{enumerate}
\end{ex}



\begin{ex}\label{exSuite_recurrente}
\begin{enumerate}
\item Soit $(u_n)$ la suite définie comme suit : $u_0=1$, $u_1=2$ et $u_{n+2}=3u_n+2u_{n+1}$. Écrire un algorithme itératif qui prend en entrée élément $n\in \N$ et qui renvoie $u_n$.

\item Écrire un algorithme récursif qui prend en entrée élément $n\in \N$ et qui renvoie $u_n$.

\item Soit $(v_n)\in \R^{\N^*}$ la suite définie comme suit : $v_1=1$, $v_2=3$ et si $n\in \N$,  $\left\{\begin{aligned} v_{2n}&= v_n^2+5 \\
v_{2n+1}&= 
 v_n v_{n+1}+7 \end{aligned}\right.$. Écrire un algorithme qui prend en entrée un élément $n\in \N^*$ et qui  détermine $v_n$. 
\end{enumerate} 
\end{ex}

 

\begin{ex}\label{exTri_selection}
Soit $L=[a_0,\ldots,a_{n-1}]$, où les $a_i$ sont des entiers.  On rappelle le principe du tri par sélection, pour trier la liste $L$ : 
on cherche d'abord l'entier (ou un des entiers) $i$ tel que  $a_i$ est le plus petit élément de la liste. On échange ensuite $a_0$ et $a_i$. On obtient alors une suite $L_1=[a_i,b_1,,\ldots,b_{n-1}]$.  On réitère ensuite le processus avec $[b_1,\ldots,b_{n-1}]$, et ainsi de suite.

Écrire un algorithme qui prend en entrée une liste d'entiers et qui la trie, en utilisant le tri par sélection.
\end{ex}



\begin{ex}\label{eqPell-fermat}(équation de Pell-Fermat)
On considère l'équation (E) $x^2-2y^2=1$, d'inconnues $x,y\in \N^*$. Écrire un algorithme qui renvoie la liste de tous les couples $(x,y)$ qui sont solution de (E) et qui vérifient $y\leq 100$. 
\end{ex}




\begin{ex}\label{exSuite_e}
\begin{enumerate}
\item Pour $n\in \N^*$, on pose $u_n=\sum_{k=0}^n \frac{1}{k!}$ et $v_n=u_n+\frac{1}{n!.n}$. Montrer que $(u_n)$ et $(v_n)$ sont adjacentes.

\item On admet que $(u_n)$ tend vers $e$. Écrire un algorithme qui prend en entrée en réel positif $\epsilon$ et qui renvoie une valeur approchée à $\epsilon$ près de $e$. 
\end{enumerate}
\end{ex}



 
\begin{ex}\label{exLecture}

\begin{enumerate}
\item On rappelle que si $a,b\in \N^*$, alors $a\wedge b=b\wedge r$, où $r$ est le reste dans la division euclidienne de $a$ par $b$.  On propose l'algorithme suivant, qui prend en entrée deux entiers $a,b\in \N$   et qui est censé déterminer leur PGCD. Fonctionne-t-il ? Si oui, le justifier, sinon, le corriger.

 \begin{tabular}{ll}
\textbf{Algorithme}($a,b$):\\
& si $a<=b$:\\
&\ \ \ {\ \rm |} $b,a\leftarrow a,b$\\
& Tant que $b\neq 0$ :  \\
&\ \ \ {\ \rm |} $b \leftarrow a$ \\
&\ \ \  {\ \rm |}b$\leftarrow a\%b$ \\
& Renvoyer $a$. 
\end{tabular}

\item Une puce se déplace sur un axe gradué que l'on identifie avec $\Z$. Au temps $t=0$, la puce est en $0$. Supposons que la puce est en $x$ à l'instant $n$. Alors à l'instant $n+1$, elle est en $x+1$ avec probabilité $1/3$, en $x+2$ avec probabilité $1/3$, en $x-3$ avec probabilité $1/3$. On souhaite programmer un algorithme simulant la position de la puce après 50 itérations. On propose l'algorithme suivant : 

 \begin{tabular}{ll}
\textbf{Algorithme}:\\
& $x=0$ \\
& Pour $t$ allant de $1$ à $50$ faire :\\
&\ \ \ {\ \rm |} Si \texttt{random}()$<1/3$: \\
&\ \ \ \ \ \ {\ \rm |} $x\leftarrow x+1$\\
&\ \ \ {\ \rm |} Si \texttt{random}()$>=1/3$ et \texttt{random}()$<2/3$: \\
&\ \ \ \ \ \ {\ \rm |} $x\leftarrow x+2$\\
&\ \ \ \ {\ \rm |}Si \texttt{random}()$>2/3$ \\
&\ \ \ \ \ \ {\ \rm |} $x\leftarrow x-3$\\
& Renvoyer $x$. 
\end{tabular}

Cet algorithme fonctionne-t-il? Si oui, le justifier, sinon, le corriger (la fonction random() retourne un nombre (pseudo)-aléatoire entre 0 et 1).

\end{enumerate}

\end{ex}

\end{document}
